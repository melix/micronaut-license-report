import com.github.vlsi.gradle.license.api.*
import groovy.json.JsonOutput
import groovy.json.StreamingJsonBuilder
import groovy.xml.DOMBuilder
import groovy.xml.XmlSlurper

import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

initscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        mavenCentral()
    }
    dependencies {
        classpath "com.github.vlsi.gradle:license-gather-plugin:1.74"
        classpath "org.codehaus.groovy:groovy-xml:3.0.8"
        classpath "org.codehaus.groovy:groovy-json:3.0.8"
    }
}

rootProject {

    def includeMicronautModulesProperty = providers.gradleProperty("includeMicronautModules").map(String::toBoolean).getOrElse(false)
    def excludedModuleIdsProperty = providers.gradleProperty("excludedModuleIds").getOrElse("")
    def aggregator = rootProject.tasks.register("licenseReport", ReportAggregator) {
        jsonAggregatedReport.set(layout.buildDirectory.file("reports/licenseReport/report.json"))
        mergedXMLReport.set(layout.buildDirectory.file("reports/licenseReport/all-licenses.xml"))
    }

    def dependencyTree = tasks.register("dependencyTree", DependencyTree) {
        Configuration config = project.getConfigurations().findByName("allCodeCoverageReportClassDirectories")
        if(config == null)
            config = project.getConfigurations().findByName("runtimeClasspath")
        rootComponent = config.getIncoming().getResolutionResult().getRoot()
        def parentDir = rootProject.projectDir.parentFile.parentFile.absolutePath
        def excludedDeps = new File(parentDir + "/src/resources/excluded_deps.txt")
        if(excludedDeps.exists())
            excludedDepsFile = excludedDeps
        dependencyTreeReport = rootProject.layout.buildDirectory.file("licenses/tree_all.txt")
    }

    def aggregatedText = tasks.register("licenseReportAggregatedText", LicenseReportText) {
        dependsOn(dependencyTree)
        depTreePath = rootProject.layout.buildDirectory.get().asFile.absolutePath + "/licenses/tree_all.txt"
        xmlReport = aggregator.flatMap(r -> r.mergedXMLReport)
        textReport = rootProject.layout.buildDirectory.file("licenses/all.txt")
        includeMicronautModules.set(includeMicronautModulesProperty)
        excludedModuleIds.set(excludedModuleIdsProperty)
    }

    allprojects {
        pluginManager.withPlugin('java') {
            pluginManager.withPlugin('maven-publish') {
                publishing {
                    publications.withType(MavenPublication).configureEach { pub ->
                        def singleReport = tasks.register("generateLicense", com.github.vlsi.gradle.license.GatherLicenseTask) {
                            configurations.set([project.configurations.runtimeClasspath])
                            SpdxLicense.values().each {
                                ignoreMissingLicenseFor(it)
                            }
                        }
                        aggregator.configure {
//                dependsOn(singleReport)
                            mustRunAfter(singleReport)
                            reports.from(new File(singleReport.get().licenseDir.asFile.get(), "license.xml"))
                        }
                        def dependencyTreeSubproject = tasks.register("dependencyTree", DependencyTree){
                            mustRunAfter(singleReport)
                            rootComponent = project.getConfigurations()
                                    .findByName("runtimeClasspath")
                                    .getIncoming()
                                    .getResolutionResult()
                                    .getRoot()
                            def parentDir = rootProject.projectDir.parentFile.parentFile.absolutePath
                            def excludedDeps = new File(parentDir + "/src/resources/excluded_deps.txt")
                            if(excludedDeps.exists())
                                excludedDepsFile = excludedDeps
                            dependencyTreeReport = rootProject.layout.buildDirectory.file("licenses/tree_${pub.groupId}:${pub.artifactId}.txt")
                        }
                        def licenseReportText = tasks.register("licenseReportText", LicenseReportText) {
                            dependsOn(dependencyTreeSubproject)
                            depTreePath = rootProject.layout.buildDirectory.get().asFile.absolutePath + "/licenses/tree_${pub.groupId}:${pub.artifactId}.txt"
                            xmlReport = new File(singleReport.get().licenseDir.asFile.get(), "license.xml")
                            textReport = rootProject.layout.buildDirectory.file("licenses/${pub.groupId}:${pub.artifactId}.txt")
                            includeMicronautModules.set(includeMicronautModulesProperty)
                            excludedModuleIds.set(excludedModuleIdsProperty)
                            def modules = configurations.runtimeClasspath
                                    .incoming
                                    .resolutionResult
                                    .allDependencies
                                    .findAll { it instanceof ResolvedDependencyResult }
                                    .collect { it.selected }
                                    .findAll { it.id instanceof ProjectComponentIdentifier }
                                    .collect { it.moduleVersion.toString() }
                            aggregatedText.configure {
                                micronautModules.addAll(modules)
                            }
                            micronautModules.set(modules)
                        }
                    }
                }
            }
        }
    }
}


static String moduleNameOf(String name) {
    if (name.startsWith("micronaut-")) {
        return name
    }
    return "micronaut-$name"
}

abstract class ReportAggregator extends DefaultTask {
    @InputFiles
    abstract ConfigurableFileCollection getReports()

    @OutputFile
    abstract RegularFileProperty getJsonAggregatedReport()

    @OutputFile
    abstract RegularFileProperty getMergedXMLReport()

    @TaskAction
    void execute() {
        writeJsonReport()
        mergeXMLReports()
    }

    private void mergeXMLReports() {
        def factory = DocumentBuilderFactory.newInstance()
        def builder = factory.newDocumentBuilder()
        def doc = builder.newDocument()
        def root = doc.createElement("license-list")
        doc.appendChild(root)
        root.setAttribute("version", "1")
        def componentsNode = root.appendChild(doc.createElement("components"))
        reports.files.each {
            if (it.exists()) {
                def dom = DOMBuilder.newInstance().parseText(it.text)
                dom.getElementsByTagName("component").each {
                    def imported = doc.importNode(it, true)
                    componentsNode.appendChild(imported)
                }
            }
        }

        def transformerFactory = TransformerFactory.newInstance()
        def trn = transformerFactory.newTransformer()

        trn.setOutputProperty(OutputKeys.ENCODING, "UTF-8")
        trn.setOutputProperty(OutputKeys.INDENT, "yes")
        trn.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")

        def file = new StreamResult(mergedXMLReport.get().asFile)

        trn.transform(new DOMSource(doc), file)

    }

    private void writeJsonReport() {
        def perComponent = [:].withDefault {
            [] as Set
        }
        def perLicense = [:].withDefault {
            [] as Set
        }
        def registerLicense = { id, node ->
            def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
            if (lic) {
                perComponent[id].add(lic)
                perLicense[lic].add(id)
            } else {
                println "License not found for $id!"
            }
        }
        reports.files.each {
            if (it.exists()) {
                def xml = new XmlSlurper()
                        .parse(it)
                xml.components.component.each {
                    def id = it.@id.text()
                    it.'license-expression'.each { expr ->
                        expr.license.each {
                            registerLicense(id, it)
                        }
                        expr.and.license.each {
                            registerLicense(id, it)
                        }
                        expr.or.license.each {
                            registerLicense(id, it)
                        }
                        expr.expression.each {
                            registerLicense(id, it)
                        }
                    }
                }
            }
        }
        def json = new StringWriter()
        new StreamingJsonBuilder(json).with { writer ->
            writer(
                    licenses: perLicense.collect { id, components ->
                        [license: [name: id, components: components]]
                    },
                    components: perComponent.collect { id, licenses ->
                        [component: [id: id, licenses: licenses]]
                    },
            )
        }
        jsonAggregatedReport.get().asFile.with {
            it.parentFile.mkdirs()
            it.text = JsonOutput.prettyPrint(json.toString())
            println "Wrote $it"
        }
    }
}

abstract class LicenseReportText extends DefaultTask {
    public static final String LICENSE_LIST_HEADER = "LICENSES LIST"
    private static final String NOT_FOUND = "License unavailable"
    private static final String[] LICENSE_FILE_PATHS = ["", "src/main/resources/META-INF/"]
    private static final String[] JACKSON_LICENSE_FILE_PATHS = ["datatypes/src/main/resources/META-INF/", "dataformat/src/main/resources/META-INF/"]
    private static final String[] LICENSE_FILE_NAMES = ["LICENSE", "License", "license", "NOTICE", "Notice", "notice", "COPYRIGHT", "Copyright", "copyright"]
    private static final String[] LICENSE_FILE_EXTENSIONS = ["", "md", "txt"]

    private static final Map<String, String> URL_CACHE = Collections.synchronizedMap([:].withDefault { key ->
        HttpURLConnection connection = new URL(key).openConnection()
        connection.requestMethod = 'GET'
        if (connection.responseCode == 200) {
            return connection.inputStream.text
        }
        return ""
    })

    private Map<String, String> licenseToComponent = [:]
    private Set<String> usableDeps = []

    @InputFile
    abstract RegularFileProperty getXmlReport()

    @OutputFile
    abstract RegularFileProperty getTextReport()

    @Input
    abstract Property<Boolean> getIncludeMicronautModules()

    @Input
    abstract Property<String> getExcludedModuleIds()

    @Optional
    @Input
    abstract SetProperty<String> getMicronautModules()

    @Internal
    abstract DirectoryProperty getRootDir()

    @Input
    abstract Property<String> getDepTreePath()

    LicenseReportText() {
        rootDir.set(project.rootProject.layout.projectDirectory)
    }

    String tryFetchLicense(String connection, String fromComponent) {
        if (!connection) {
            return
        }
        String baseUri = null
        def idx = connection.indexOf("http://bitbucket.org/")
        if (idx == -1) {
            idx = connection.indexOf("https://bitbucket.org/")
        }
        if (idx == -1) {
            idx = connection.indexOf("https://gitlab.ow2.org/")
        }
        if(idx == -1){
            idx = connection.indexOf("http://gitbox.apache.org/")
            if(idx != -1) {
                //Changing the source site from gitbox to github by getting the name of the module from the connection,
                // as it is easier to work with than gitbox
                String path = "apache/" + connection.tokenize('/').last() - ".git"
                baseUri = "https://raw.githubusercontent.com/$path/master"
            }
        }
        if (idx > 0 && baseUri == null) {
            baseUri = "${connection.substring(idx).replace('http:', 'https:')}/raw/master"
        } else {
            idx = connection.indexOf("github.com")
            if (idx > 0) {
                String path = connection.substring(idx + 10).replaceAll(':', '/') - ".git"
                baseUri = "https://raw.githubusercontent.com/$path/master"
            }
        }

        if (baseUri) {
            String result = tryManyLicenses(baseUri, fromComponent)
            if (result) {
                return result
            }
        } else {
            println("Unknown connection -> $connection")
        }
        return ""
    }

    String deduplicate(String licenseText, String fromComponent) {
        String normalized = licenseText.trim()
        String cid = licenseToComponent[normalized]
        if (cid) {
            return "Same as " + removeVersion(cid)
        }
        licenseToComponent[normalized] = fromComponent
        licenseText
    }

    String removeVersion(String componentId) {
        def idForDisplay = componentId
        def lastIndexColon = componentId.lastIndexOf(":")
        if (lastIndexColon != -1) {
            idForDisplay = componentId.substring(0, lastIndexColon)
        }
        idForDisplay
    }

    StringBuilder tryManyLicensesJackson(String baseUri, String fromComponent, Set<String> seen, StringBuilder sb){
        if(fromComponent.contains("jackson-modules-java8"))
            baseUri = baseUri - "/master" + "/2.14"
        [JACKSON_LICENSE_FILE_PATHS, LICENSE_FILE_NAMES, LICENSE_FILE_EXTENSIONS].combinations().each { fp, f, ext ->
            String fileName = f.toLowerCase()
            if(seen.contains(fileName))
                return
            def fn = ext ? "${f}.${ext}" : f
            def txt = URL_CACHE.get("${baseUri}/${fp}${fn}")
            if (txt) {
                sb.append("${fn}\n")
                sb.append("-" * fn.length()).append("\n")
                sb.append(deduplicate(txt, fromComponent)).append("\n\n")
                seen.add(fileName)
            }
        }
        return sb
    }

    String tryManyLicenses(String baseUri, String fromComponent) {
        StringBuilder sb = new StringBuilder()
        Set<String> seen = []
        [LICENSE_FILE_PATHS, LICENSE_FILE_NAMES, LICENSE_FILE_EXTENSIONS].combinations().each { fp, f, ext ->
            String fileName = f.toLowerCase()
            if(seen.contains(fileName))
                return
            def fn = ext ? "${f}.${ext}" : f
            def txt = URL_CACHE.get("${baseUri}/${fp}${fn}")
            if (txt) {
                sb.append("${fn}\n")
                sb.append("-" * fn.length()).append("\n")
                sb.append(deduplicate(txt, fromComponent)).append("\n\n")
                seen.add(f.toLowerCase())
            }
        }
        if(fromComponent.toLowerCase().contains("jackson"))
            sb = tryManyLicensesJackson(baseUri, fromComponent, seen, sb)
        return sb.toString()
    }

    String fetchLicenseTextFromRepo(String componentId) {
        try {
            def (String g, String a, String v) = componentId.split(':')
            def result = project.dependencies.createArtifactResolutionQuery()
                    .forModule(g, a, v)
                    .withArtifacts(MavenModule, MavenPomArtifact)
                    .execute()
            def tentativeLicense = null
            result.resolvedComponents.each {
                it.getArtifacts(MavenPomArtifact).each {
                    if (tentativeLicense) {
                        return
                    }
                    def xmlFile = it.file
                    def xml = new XmlSlurper().parse(xmlFile)
                    def connection = xml.scm.connection ? xml.scm.connection[0].text() : ""
                    if (!connection) {
                        // Let's see if we can get it from the parent pom
                        if (xml.'parent'.groupId.text()) {
                            def parentPom = "${xml.'parent'.groupId.text()}:${xml.'parent'.artifactId.text()}:${xml.'parent'.version.text()}"
                            tentativeLicense = fetchLicenseTextFromRepo(parentPom)
                        }
                    } else {
                        tentativeLicense = tryFetchLicense(connection, "$g:$a:$v")
                    }
                    if (!tentativeLicense || tentativeLicense == NOT_FOUND) {
                        tentativeLicense = xml.licenses.license.url*.text().join(" ")
                    }
                }
            }
            result.components
                    .findAll { it instanceof UnresolvedComponentResult }
                    .each {
                        ((UnresolvedComponentResult) it).failure.printStackTrace()
                    }
            return tentativeLicense ?: NOT_FOUND
        } catch (e) {
            println "Unexpected error while processing $componentId"
            e.printStackTrace()
            return NOT_FOUND
        }
    }

    File[] findLicensesInDir(File licenseFile){
        def licenseFiles = []
        if(!licenseFile.isDirectory())
            licenseFiles << licenseFile
        else {
            licenseFile.eachFileRecurse { File file ->
                if (!file.isDirectory() && file.name.toUpperCase().startsWithAny(LICENSE_FILE_NAMES))
                    licenseFiles << file
            }
        }
        return licenseFiles
    }

    boolean findUsableDepsFromTree(){
        File depTreeFile = new File(depTreePath.get())
        if(!depTreeFile.exists())
            return false

        def lines = depTreeFile.readLines()
        for(String line in lines){
            String trimmed = line.trim()
            if(trimmed == "")
                return true
            usableDeps.add(trimmed.toLowerCase())
        }
        return true
    }

    boolean checkUsableDep(String depId){
        if (includeMicronautModules.get() && depId.startsWith('io.micronaut')) {
            println("Micronaut module: ${depId}")
            return true
        }
        if(usableDeps.contains(depId.trim().toLowerCase()))
            return true
        return false
    }

    @TaskAction
    void execute() {
        def xmlFile = xmlReport.get().asFile
        def txtFile = textReport.get().asFile
        if(!findUsableDepsFromTree())
            return
        txtFile.withWriter { writer ->
            def baseDir = xmlFile.parentFile.toPath()
            def xml = new XmlSlurper()
                    .parse(xmlFile)
            def registerLicense = { id, node ->
                def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
                def uri
                if (lic) {
                    uri = node.@uri.text()
                    if (uri) {
                        writer.println("$lic: $uri")
                        writer.println()
                    } else {
                        def licenseText = fetchLicenseTextFromRepo(id)
                        writer.println("$lic: $licenseText")
                    }
                }
            }
            // At the top of the file we put a list of all dependencies
            def components = [] as LinkedHashSet
            if (includeMicronautModules.get() && getMicronautModules().isPresent()) {
                getMicronautModules().get().each {
                    components << it
                }
            }
            xml.components.component.each {
                def id = it.@id.text()
                if (!includeMicronautModules.get() && id.startsWith('io.micronaut'))
                    // skip this component
                    return
                if(checkUsableDep((String) id))
                    components << id
            }
            components = components.sort()
            components.each {
                writer.println(it)
            }
            writer.println()
            writer.println(LICENSE_LIST_HEADER)
            writer.println("-------------")
            // Then licenses for each component
            // also sorted
            components.each { compId ->
                if (compId.startsWith('io.micronaut')) {
                    // special case because we know it'a AL2
                    def idForDisplay = removeVersion(compId)
                    writer.println(idForDisplay)
                    writer.println('=' * idForDisplay.length())
                    File licFile = rootDir.file("LICENSE").get().asFile
                    if (licFile.exists()) {
                        writer.println(licFile.name)
                        writer.println("-" * (licFile.name.length()))
                        writer.println(deduplicate(licFile.text, compId))
                    } else {
                        writer.println("LICENSE file not found")
                    }
                    return
                }
                Set<String> usedModuleIds = []
                xml.components.component.each {
                    String id = it.@id.text()
                    if (id != compId) {
                        return
                    }
                    def path = it.@licenseFiles.text()
                    def idForDisplay = removeVersion(id)
                    //skip duplicates
                    if(!usedModuleIds.add(idForDisplay)){return}
//                  skip excluded Modules from the licenses report
                    def excluded_Module_Ids=excludedModuleIds.get().split(";")
                    if(excluded_Module_Ids.any {it && idForDisplay.contains(it)}){
                        return
                    }
                    writer.println(idForDisplay)
                    writer.println('=' * idForDisplay.length())
                    boolean hasLicenses = false
                    if (path) {
                        def licenses = baseDir.resolve(path).toFile()
                        if (licenses.exists()) {
                            licenses.listFiles().each {
                                //If the directory in which the licenses should be has subdirectories instead,
                                //check whether the licenses are present in any of those subfolders
                                def licFiles = findLicensesInDir(it).toList()
                                if(licFiles.isEmpty())
                                    return
                                hasLicenses = true
                                licFiles.each {File file ->
                                    writer.println(file.name)
                                    writer.println("-" * (file.name.length()))
                                    writer.println(deduplicate(file.text, id))
                                }
                            }
                        }
                        writer.println()
                    }
                    if (!hasLicenses) {
                        it.'license-expression'.each { expr ->
                            expr.license.each {
                                registerLicense(id, it)
                            }
                            expr.and.license.each {
                                registerLicense(id, it)
                            }
                            expr.or.license.each {
                                registerLicense(id, it)
                            }
                            expr.expression.each {
                                registerLicense(id, it)
                            }
                        }
                    }
                }

            }
        }
        println "Wrote $txtFile"
    }
}


abstract class DependencyTree extends DefaultTask{

    private Set<String> excludedDeps = []

    @Input
    abstract Property<ResolvedComponentResult> getRootComponent()

    @Optional
    @InputFile
    abstract RegularFileProperty getExcludedDepsFile()

    @OutputFile
    abstract RegularFileProperty getDependencyTreeReport()

    void printDependencyTree(){
        try {
            ResolvedComponentResult root = getRootComponent().get()
            Set<ComponentIdentifier> seen = []

            if(root == null){
                println("Couldn't find the root for the given configuration")
                return
            }

            getExcludedDeps()
            seen.add(root.id)
            StringBuilder sb = new StringBuilder()

            if(checkExcludedDeps(root.id))
                return

            sb = printDependencyTreePreorder(root, seen, 0, "", sb)
            def seenSorted = seen.sort{it.displayName}

            def depTreeFile = dependencyTreeReport.get().asFile
            if(!depTreeFile.exists())
                depTreeFile.createNewFile()

            depTreeFile.withWriter {writer ->
                seenSorted.each {compId ->
                    if(!compId.displayName.trim().toLowerCase().startsWith("project"))
                        writer.println(compId.displayName)
                }

                writer.println()
                writer.println(sb.toString())
            }
        }catch(Exception e){
            return
        }
    }

    void getExcludedDeps(){
        if(!excludedDepsFile.isPresent())
            return

        File exclusionsFile = excludedDepsFile.get().asFile
        def lines = exclusionsFile.readLines()

        for(String line in lines){
            excludedDeps.add(line.trim())
        }
    }

    StringBuilder printDependencyTreePreorder(ResolvedComponentResult root,
                                              Set<ComponentIdentifier> seen,
                                              int depth,
                                              String beforeComponent,
                                              StringBuilder sb){

        Set<DependencyResult> dependencies = root.getDependencies()
        Set<ComponentIdentifier> seenBranch = []
        sb = printDependency(root, beforeComponent, sb, false, depth, dependencies.isEmpty())
        if(depth > 0 && !dependencies.isEmpty())
            beforeComponent += "|   "

        for(DependencyResult d: dependencies) {
            if (!(d instanceof ResolvedDependencyResult)) {
                sb.append(beforeComponent + "---- ")
                sb.append("Unresolved dependency: " + d.toString() + "\n")
                continue
            }

            ResolvedComponentResult dependencyComponent = ((ResolvedDependencyResult) d).getSelected()
            ComponentIdentifier dependencyId = dependencyComponent.getId()

            if(checkExcludedDeps(dependencyId))
                continue

            if(seen.add(dependencyId))
                sb = printDependencyTreePreorder(dependencyComponent, seen, depth + 1, beforeComponent + "    ", sb)
            else if(!seenBranch.contains(dependencyId))
                sb = printDependency(dependencyComponent, beforeComponent + "    ", sb, true, depth + 1, dependencyComponent.getDependencies().isEmpty())

            seenBranch.add(dependencyId)
        }
        return sb
    }

    boolean checkExcludedDeps(ComponentIdentifier dependencyId){
        for(String exclusion in excludedDeps){
            if(dependencyId.displayName.contains(exclusion))
                return true
        }
        return false
    }

    StringBuilder printDependency(ResolvedComponentResult root,
                                  String beforeComponent,
                                  StringBuilder sb,
                                  boolean alreadySeen,
                                  int depth,
                                  boolean emptyDependencies){

        sb.append(beforeComponent)
        if(depth > 0) {
            if (emptyDependencies)
                sb.append("/--- ")
            else {
                sb.append("+--- ")
            }
        }
        sb.append(root.getId().getDisplayName())
        if(alreadySeen == true) {
            sb.append(" (*)")
        }
        sb.append("\n")
        return sb
    }

    @TaskAction
    void execute(){
        printDependencyTree()
        //tryOptional()
    }

    void tryOptional(){
        try {
            Configuration config = project.getConfigurations().findByName("allCodeCoverageReportClassDirectories")
            if(config == null)
                config = project.getConfigurations().findByName("runtimeClasspath")
            StringBuilder sb = new StringBuilder()

            config.getIncoming().dependencies.each {dep ->
                config.files(dep).each {file ->
                    sb.append(file.name + "\n")
                    findPomFile(file)
                }
            }
        }catch(Exception e){
            return
        }
    }

    void findPomFile(File dependencyFile){
        def parentDir = dependencyFile.parentFile.parentFile

        if(!parentDir.isDirectory())
            return

        parentDir.eachFileRecurse {pomFile ->
            if(pomFile.name.endsWith(".pom"))
                findOptionalDeps(pomFile)
        }
    }

    void findOptionalDeps(File pomFile){
        def pomXml = new XmlSlurper().parse(pomFile)
        pomXml.dependencies."*".find{node ->
            String optional = node.optional.text()
            if(optional.trim().toLowerCase() == "true") {
                String depName = node.groupId.text() + ":" + node.artifactId.text() + ":" + node.version.text()
                //println("depname: " + depName)
            }
        }
    }
}
