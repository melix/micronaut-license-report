import com.github.vlsi.gradle.license.api.*
import groovy.json.JsonOutput
import groovy.json.StreamingJsonBuilder
import groovy.xml.DOMBuilder
import groovy.xml.XmlSlurper

import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

initscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        mavenCentral()
    }
    dependencies {
        classpath "com.github.vlsi.gradle:license-gather-plugin:1.74"
        classpath "org.codehaus.groovy:groovy-xml:3.0.8"
        classpath "org.codehaus.groovy:groovy-json:3.0.8"
    }
}

rootProject {

    def includeMicronautModulesProperty = providers.gradleProperty("includeMicronautModules").map(String::toBoolean).getOrElse(false)
    def aggregator = rootProject.tasks.register("licenseReport", ReportAggregator) {
        jsonAggregatedReport.set(layout.buildDirectory.file("reports/licenseReport/report.json"))
        mergedXMLReport.set(layout.buildDirectory.file("reports/licenseReport/all-licenses.xml"))
    }
    def aggregatedText = tasks.register("licenseReportAggregatedText", LicenseReportText) {
        xmlReport = aggregator.flatMap(r -> r.mergedXMLReport)
        textReport = rootProject.layout.buildDirectory.file("licenses/all.txt")
        includeMicronautModules.set(includeMicronautModulesProperty)
    }

    def dependencyTree = tasks.register("dependencyTree", DependencyTree) {
        dependencyTreeReport = rootProject.layout.buildDirectory.file("licenses/tree_all.txt")
    }

    allprojects {
        pluginManager.withPlugin('java') {
            pluginManager.withPlugin('maven-publish') {
                publishing {
                    publications.withType(MavenPublication).configureEach { pub ->
                        def singleReport = tasks.register("generateLicense", com.github.vlsi.gradle.license.GatherLicenseTask) {
                            configurations.set([project.configurations.runtimeClasspath])
                            SpdxLicense.values().each {
                                ignoreMissingLicenseFor(it)
                            }
                        }
                        aggregator.configure {
//                dependsOn(singleReport)
                            mustRunAfter(singleReport)
                            reports.from(new File(singleReport.get().licenseDir.asFile.get(), "license.xml"))
                        }
                        def licenseReportText = tasks.register("licenseReportText", LicenseReportText) {
                            mustRunAfter(singleReport)
                            xmlReport = new File(singleReport.get().licenseDir.asFile.get(), "license.xml")
                            textReport = rootProject.layout.buildDirectory.file("licenses/${pub.groupId}:${pub.artifactId}.txt")
                            includeMicronautModules.set(includeMicronautModulesProperty)
                        }
                        tasks.register("dependencyTree", DependencyTree){
                            mustRunAfter(licenseReportText)
                            dependencyTreeReport = rootProject.layout.buildDirectory.file("licenses/tree_${pub.groupId}:${pub.artifactId}.txt")
                        }
                    }
                }
            }
        }
    }
}

abstract class ReportAggregator extends DefaultTask {
    @InputFiles
    abstract ConfigurableFileCollection getReports()

    @OutputFile
    abstract RegularFileProperty getJsonAggregatedReport()

    @OutputFile
    abstract RegularFileProperty getMergedXMLReport()

    @TaskAction
    void execute() {
        writeJsonReport()
        mergeXMLReports()
    }

    private void mergeXMLReports() {
        def factory = DocumentBuilderFactory.newInstance()
        def builder = factory.newDocumentBuilder()
        def doc = builder.newDocument()
        def root = doc.createElement("license-list")
        doc.appendChild(root)
        root.setAttribute("version", "1")
        def componentsNode = root.appendChild(doc.createElement("components"))
        reports.files.each {
            if (it.exists()) {
                def dom = DOMBuilder.newInstance().parseText(it.text)
                dom.getElementsByTagName("component").each {
                    def imported = doc.importNode(it, true)
                    componentsNode.appendChild(imported)
                }
            }
        }

        def transformerFactory = TransformerFactory.newInstance()
        def trn = transformerFactory.newTransformer()

        trn.setOutputProperty(OutputKeys.ENCODING, "UTF-8")
        trn.setOutputProperty(OutputKeys.INDENT, "yes")
        trn.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")

        def file = new StreamResult(mergedXMLReport.get().asFile)

        trn.transform(new DOMSource(doc), file)

    }

    private void writeJsonReport() {
        def perComponent = [:].withDefault {
            [] as Set
        }
        def perLicense = [:].withDefault {
            [] as Set
        }
        def registerLicense = { id, node ->
            def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
            if (lic) {
                perComponent[id].add(lic)
                perLicense[lic].add(id)
            } else {
                println "License not found for $id!"
            }
        }
        reports.files.each {
            if (it.exists()) {
                def xml = new XmlSlurper()
                        .parse(it)
                xml.components.component.each {
                    def id = it.@id.text()
                    it.'license-expression'.each { expr ->
                        expr.license.each {
                            registerLicense(id, it)
                        }
                        expr.and.license.each {
                            registerLicense(id, it)
                        }
                        expr.or.license.each {
                            registerLicense(id, it)
                        }
                        expr.expression.each {
                            registerLicense(id, it)
                        }
                    }
                }
            }
        }
        def json = new StringWriter()
        new StreamingJsonBuilder(json).with { writer ->
            writer(
                    licenses: perLicense.collect { id, components ->
                        [license: [name: id, components: components]]
                    },
                    components: perComponent.collect { id, licenses ->
                        [component: [id: id, licenses: licenses]]
                    },
            )
        }
        jsonAggregatedReport.get().asFile.with {
            it.parentFile.mkdirs()
            it.text = JsonOutput.prettyPrint(json.toString())
            println "Wrote $it"
        }
    }
}

abstract class LicenseReportText extends DefaultTask {
    public static final String LICENSE_LIST_HEADER = "LICENSES LIST"
    private static final String NOT_FOUND = "License unavailable"
    private static final String[] LICENSE_FILE_PATHS = ["", "src/main/resources/META-INF/"]
    private static final String[] JACKSON_LICENSE_FILE_PATHS = ["yaml/src/main/resources/META-INF/", "datatypes/src/main/resources/META-INF/"]
    private static final String[] LICENSE_FILE_NAMES = ["LICENSE", "NOTICE", "COPYRIGHT"]
    private static final String[] LICENSE_FILE_EXTENSIONS = ["", "md", "txt"]

    private static final Map<String, String> URL_CACHE = Collections.synchronizedMap([:].withDefault { key ->
        HttpURLConnection connection = new URL(key).openConnection()
        connection.requestMethod = 'GET'
        if (connection.responseCode == 200) {
            return connection.inputStream.text
        }
        return ""
    })

    private Map<String, String> licenseToComponent = [:]

    @InputFile
    abstract RegularFileProperty getXmlReport()

    @OutputFile
    abstract RegularFileProperty getTextReport()

    @Input
    abstract Property<Boolean> getIncludeMicronautModules()

    String tryFetchLicense(String connection, String fromComponent) {
        if (!connection) {
            return
        }
        String baseUri = null
        def idx = connection.indexOf("http://bitbucket.org/")
        if (idx == -1) {
            idx = connection.indexOf("https://bitbucket.org/")
        }
        if (idx == -1) {
            idx = connection.indexOf("https://gitlab.ow2.org/")
        }
        if(idx == -1){
            idx = connection.indexOf("http://gitbox.apache.org/")
            if(idx != -1) {
                //Changing the source site from gitbox to github by getting the name of the module from the connection,
                // as it is easier to work with than gitbox
                String path = "apache/" + connection.tokenize('/').last() - ".git"
                baseUri = "https://raw.githubusercontent.com/$path/master"
            }
        }
        if (idx > 0 && baseUri == null) {
            baseUri = "${connection.substring(idx).replace('http:', 'https:')}/raw/master"
        } else {
            idx = connection.indexOf("github.com")
            if (idx > 0) {
                String path = connection.substring(idx + 10).replaceAll(':', '/') - ".git"
                baseUri = "https://raw.githubusercontent.com/$path/master"
            }
        }

        if (baseUri) {
            String result = tryManyLicenses(baseUri, fromComponent)
            if (result) {
                return result
            }
        } else {
            println("Unknown connection -> $connection")
        }
        return ""
    }

    String deduplicate(String licenseText, String fromComponent) {
        String normalized = licenseText.trim()
        String cid = licenseToComponent[normalized]
        if (cid) {
            return "Same as " + removeVersion(cid)
        }
        licenseToComponent[normalized] = fromComponent
        licenseText
    }

    String removeVersion(String componentId) {
        def idForDisplay = componentId
        def lastIndexColon = componentId.lastIndexOf(":")
        if (lastIndexColon != -1) {
            idForDisplay = componentId.substring(0, lastIndexColon)
        }
        idForDisplay
    }

    StringBuilder tryManyLicensesJackson(String baseUri, String fromComponent, Set<String> licensesFound, StringBuilder sb){
        if(fromComponent.contains("jackson-modules-java8"))
            baseUri = baseUri - "/master" + "/2.15"
        [JACKSON_LICENSE_FILE_PATHS, LICENSE_FILE_NAMES, LICENSE_FILE_EXTENSIONS].combinations().each { fp, f, ext ->
            if(f in licensesFound)
                return
            def fn = ext ? "${f}.${ext}" : f
            def txt = URL_CACHE.get("${baseUri}/${fp}${fn}")
            if (txt) {
                sb.append("${fn}\n")
                sb.append("-" * fn.length()).append("\n")
                sb.append(deduplicate(txt, fromComponent)).append("\n\n")
                licensesFound.add(f)
            }
        }
        return sb
    }

    String tryManyLicenses(String baseUri, String fromComponent) {
        StringBuilder sb = new StringBuilder()
        Set<String> licensesFound = []
        [LICENSE_FILE_PATHS, LICENSE_FILE_NAMES, LICENSE_FILE_EXTENSIONS].combinations().each { fp, f, ext ->
            def fn = ext ? "${f}.${ext}" : f
            def txt = URL_CACHE.get("${baseUri}/${fp}${fn}")
            if (txt) {
                sb.append("${fn}\n")
                sb.append("-" * fn.length()).append("\n")
                sb.append(deduplicate(txt, fromComponent)).append("\n\n")
                licensesFound.add(f)
            }
        }
        if(fromComponent.contains("jackson"))
            sb = tryManyLicensesJackson(baseUri, fromComponent, licensesFound, sb)
        return sb.toString()
    }

    String fetchLicenseTextFromRepo(String componentId) {
        try {
            def (String g, String a, String v) = componentId.split(':')
            def result = project.dependencies.createArtifactResolutionQuery()
                    .forModule(g, a, v)
                    .withArtifacts(MavenModule, MavenPomArtifact)
                    .execute()
            def tentativeLicense = null
            result.resolvedComponents.each {
                it.getArtifacts(MavenPomArtifact).each {
                    if (tentativeLicense) {
                        return
                    }
                    def xmlFile = it.file
                    def xml = new XmlSlurper().parse(xmlFile)
                    def connection = xml.scm.connection ? xml.scm.connection[0].text() : ""
                    if (!connection) {
                        // Let's see if we can get it from the parent pom
                        if (xml.'parent'.groupId.text()) {
                            def parentPom = "${xml.'parent'.groupId.text()}:${xml.'parent'.artifactId.text()}:${xml.'parent'.version.text()}"
                            tentativeLicense = fetchLicenseTextFromRepo(parentPom)
                        }
                    } else {
                        tentativeLicense = tryFetchLicense(connection, "$g:$a:$v")
                    }
                    if (!tentativeLicense || tentativeLicense == NOT_FOUND) {
                        tentativeLicense = xml.licenses.license.url*.text().join(" ")
                    }
                }
            }
            result.components
                    .findAll { it instanceof UnresolvedComponentResult }
                    .each {
                        ((UnresolvedComponentResult) it).failure.printStackTrace()
                    }
            return tentativeLicense ?: NOT_FOUND
        } catch (e) {
            println "Unexpected error while processing $componentId"
            e.printStackTrace()
            return NOT_FOUND
        }
    }

    File[] findLicensesInDir(File licenseFile){
        def licenseFiles = []
        if(!licenseFile.isDirectory())
            licenseFiles << licenseFile
        else {
            licenseFile.eachFileRecurse { File file ->
                if (!file.isDirectory() && file.name.toUpperCase().startsWithAny(LICENSE_FILE_NAMES))
                    licenseFiles << file
            }
        }
        return licenseFiles
    }

    @TaskAction
    void execute() {
        def xmlFile = xmlReport.get().asFile
        def txtFile = textReport.get().asFile
        txtFile.withWriter { writer ->
            def baseDir = xmlFile.parentFile.toPath()
            def xml = new XmlSlurper()
                    .parse(xmlFile)
            def registerLicense = { id, node ->
                def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
                def uri
                if (lic) {
                    uri = node.@uri.text()
                    if (uri) {
                        writer.println("$lic: $uri")
                        writer.println()
                    } else {
                        def licenseText = fetchLicenseTextFromRepo(id)
                        writer.println("$lic: $licenseText")
                    }
                }
            }
            // At the top of the file we put a list of all dependencies
            def components = [] as LinkedHashSet
            xml.components.component.each {
                def id = it.@id.text()
                if (!includeMicronautModules.get() && id.startsWith('io.micronaut')) {
                    // skip this component
                    return
                }
                components << id
            }
            components = components.sort()
            components.each {
                writer.println(it)
            }
            writer.println()
            writer.println(LICENSE_LIST_HEADER)
            writer.println("-------------")

            // Then licenses for each component
            // also sorted
            components.each { compId ->
                xml.components.component.each {
                    String id = it.@id.text()
                    if (id != compId) {
                        return
                    }
                    def path = it.@licenseFiles.text()
                    def idForDisplay = removeVersion(id)
                    writer.println(idForDisplay)
                    writer.println('=' * idForDisplay.length())
                    boolean hasLicenses = false
                    if (path) {
                        def licenses = baseDir.resolve(path).toFile()
                        if (licenses.exists()) {
                            licenses.listFiles().each {
                                //If the directory in which the licenses should be has subdirectories instead,
                                //check whether the licenses are present in any of those subfolders
                                def licFiles = findLicensesInDir(it).toList()
                                if(licFiles.isEmpty())
                                    return
                                hasLicenses = true
                                licFiles.each {File file ->
                                    writer.println(file.name)
                                    writer.println("-" * (file.name.length()))
                                    writer.println(deduplicate(file.text, id))
                                }
                            }
                        }
                        writer.println()
                    }
                    if (!hasLicenses) {
                        it.'license-expression'.each { expr ->
                            expr.license.each {
                                registerLicense(id, it)
                            }
                            expr.and.license.each {
                                registerLicense(id, it)
                            }
                            expr.or.license.each {
                                registerLicense(id, it)
                            }
                            expr.expression.each {
                                registerLicense(id, it)
                            }
                        }
                    }
                }

            }
        }
        println "Wrote $txtFile"
    }
}


abstract class DependencyTree extends DefaultTask{

    private static final String[] excludedDeps = ["jackson-annotations", "bom"]

    @OutputFile
    abstract RegularFileProperty getDependencyTreeReport()

    void printDependencyTree(){
        try {
            Configuration config = project.getConfigurations().getByName("allCodeCoverageReportClassDirectories")
            if (!config.isCanBeResolved()) {
                println("Configuration allCodeCoverageReportClassDirectories could not be resolved")
                return
            }

            ResolvedComponentResult root = config.getIncoming()
                    .getResolutionResult()
                    .getRoot();
            Set<ComponentIdentifier> seen = []

            StringBuilder sb = new StringBuilder()
            sb = printDependencyTreePreorder(root, seen, 0, "", sb)
            def seenSorted = seen.sort{it.displayName}

            def depTreeFile = dependencyTreeReport.get().asFile
            if(!depTreeFile.exists())
                depTreeFile.createNewFile()

            depTreeFile.withWriter {writer ->
                seenSorted.each {compId ->
                    if(!compId.displayName.toLowerCase().startsWith("project"))
                    writer.println(compId.displayName)
                }

                writer.println()
                writer.println("${config.name} - ${config.description}")
                writer.println(sb.toString())
            }
        }catch(Exception e){
            return
        }
    }

    StringBuilder printDependencyTreePreorder(ResolvedComponentResult root,
                                              Set<ComponentIdentifier> seen,
                                              int depth,
                                              String beforeComponent,
                                              StringBuilder sb){

        Set<DependencyResult> dependencies = root.getDependencies()
        Set<ComponentIdentifier> seenBranch = []
        sb = printDependency(root, beforeComponent, sb, false, depth, dependencies.isEmpty())
        if(depth > 0 && !dependencies.isEmpty())
            beforeComponent += "|   "

        for(DependencyResult d: dependencies) {
            if (!(d instanceof ResolvedDependencyResult)) {
                sb.append(beforeComponent + "---- ")
                sb.append("Unresolved dependency: " + d.toString() + "\n")
                continue
            }

            ResolvedComponentResult dependencyComponent = ((ResolvedDependencyResult) d).getSelected()
            ComponentIdentifier dependencyId = dependencyComponent.getId()

            if(checkExcludedDeps(dependencyId))
                continue

            if(seen.add(dependencyId))
                sb = printDependencyTreePreorder(dependencyComponent, seen, depth + 1, beforeComponent + "    ", sb)
            else if(!seenBranch.contains(dependencyId))
                sb = printDependency(dependencyComponent, beforeComponent + "    ", sb, true, depth, dependencies.isEmpty())

            seenBranch.add(dependencyId)
        }
        return sb
    }

    boolean checkExcludedDeps(ComponentIdentifier dependencyId){
        for(String exclusion in excludedDeps){
            if(dependencyId.displayName.contains(exclusion))
                return true
        }
        return false
    }

    StringBuilder printDependency(ResolvedComponentResult root,
                                  String beforeComponent,
                                  StringBuilder sb,
                                  boolean alreadySeen,
                                  int depth,
                                  boolean emptyDependencies){

        sb.append(beforeComponent)
        if(depth > 0) {
            if (emptyDependencies)
                sb.append("/--- ")
            else {
                sb.append("+--- ")
            }
        }
        sb.append(root.getId().getDisplayName())
        if(alreadySeen == true) {
            sb.append(" (*)")
        }
        sb.append("\n")
        return sb
    }

    @TaskAction
    void execute(){
        printDependencyTree()
    }
}
