import com.github.vlsi.gradle.license.api.*
import groovy.json.JsonOutput
import groovy.json.StreamingJsonBuilder
import groovy.xml.DOMBuilder
import groovy.xml.XmlSlurper

import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

initscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        mavenCentral()
    }
    dependencies {
        classpath "com.github.vlsi.gradle:license-gather-plugin:1.74"
        classpath "org.codehaus.groovy:groovy-xml:3.0.8"
        classpath "org.codehaus.groovy:groovy-json:3.0.8"
    }
}

rootProject {

    def aggregator = rootProject.tasks.register("licenseReport", ReportAggregator) {
        jsonAggregatedReport.set(layout.buildDirectory.file("reports/licenseReport/report.json"))
        mergedXMLReport.set(layout.buildDirectory.file("reports/licenseReport/all-licenses.xml"))
    }
    def aggregatedText = tasks.register("licenseReportAggregatedText", LicenseReportText) {
        xmlReport = aggregator.flatMap(r -> r.mergedXMLReport)
        textReport = rootProject.layout.buildDirectory.file("licenses/all.txt")
    }

    allprojects {
        pluginManager.withPlugin('java') {
            pluginManager.withPlugin('maven-publish') {
                publishing {
                    publications.withType(MavenPublication).configureEach { pub ->
                        def singleReport = tasks.register("generateLicense", com.github.vlsi.gradle.license.GatherLicenseTask) {
                            configurations.set([project.configurations.runtimeClasspath])
                            SpdxLicense.values().each {
                                ignoreMissingLicenseFor(it)
                            }
                        }
                        aggregator.configure {
//                dependsOn(singleReport)
                            mustRunAfter(singleReport)
                            reports.from(new File(singleReport.get().licenseDir.asFile.get(), "license.xml"))
                        }
                        tasks.register("licenseReportText", LicenseReportText) {
                            mustRunAfter(singleReport)
                            xmlReport = new File(singleReport.get().licenseDir.asFile.get(), "license.xml")
                            textReport = rootProject.layout.buildDirectory.file("licenses/${pub.groupId}:${pub.artifactId}.txt")
                        }
                    }
                }
            }
        }
    }
}

abstract class ReportAggregator extends DefaultTask {
    @InputFiles
    abstract ConfigurableFileCollection getReports()

    @OutputFile
    abstract RegularFileProperty getJsonAggregatedReport()

    @OutputFile
    abstract RegularFileProperty getMergedXMLReport()

    @TaskAction
    void execute() {
        writeJsonReport()
        mergeXMLReports()
    }

    private void mergeXMLReports() {
        def factory = DocumentBuilderFactory.newInstance()
        def builder = factory.newDocumentBuilder()
        def doc = builder.newDocument()
        def root = doc.createElement("license-list")
        doc.appendChild(root)
        root.setAttribute("version", "1")
        def componentsNode = root.appendChild(doc.createElement("components"))
        reports.files.each {
            if (it.exists()) {
                def dom = DOMBuilder.newInstance().parseText(it.text)
                dom.getElementsByTagName("component").each {
                    def imported = doc.importNode(it, true)
                    componentsNode.appendChild(imported)
                }
            }
        }

        def transformerFactory = TransformerFactory.newInstance()
        def trn = transformerFactory.newTransformer()

        trn.setOutputProperty(OutputKeys.ENCODING, "UTF-8")
        trn.setOutputProperty(OutputKeys.INDENT, "yes")
        trn.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")

        def file = new StreamResult(mergedXMLReport.get().asFile)

        trn.transform(new DOMSource(doc), file)

    }

    private void writeJsonReport() {
        def perComponent = [:].withDefault {
            [] as Set
        }
        def perLicense = [:].withDefault {
            [] as Set
        }
        def registerLicense = { id, node ->
            def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
            if (lic) {
                perComponent[id].add(lic)
                perLicense[lic].add(id)
            } else {
                println "License not found for $id!"
            }
        }
        reports.files.each {
            if (it.exists()) {
                def xml = new XmlSlurper()
                        .parse(it)
                xml.components.component.each {
                    def id = it.@id.text()
                    it.'license-expression'.each { expr ->
                        expr.license.each {
                            registerLicense(id, it)
                        }
                        expr.and.license.each {
                            registerLicense(id, it)
                        }
                        expr.or.license.each {
                            registerLicense(id, it)
                        }
                        expr.expression.each {
                            registerLicense(id, it)
                        }
                    }
                }
            }
        }
        def json = new StringWriter()
        new StreamingJsonBuilder(json).with { writer ->
            writer(
                    licenses: perLicense.collect { id, components ->
                        [license: [name: id, components: components]]
                    },
                    components: perComponent.collect { id, licenses ->
                        [component: [id: id, licenses: licenses]]
                    },
            )
        }
        jsonAggregatedReport.get().asFile.with {
            it.parentFile.mkdirs()
            it.text = JsonOutput.prettyPrint(json.toString())
            println "Wrote $it"
        }
    }
}

abstract class LicenseReportText extends DefaultTask {
    public static final String LICENSE_LIST_HEADER = "LICENSES LIST"
    private static final String NOT_FOUND = "License unavailable"
    private static final String[] LICENSE_FILE_PATHS = ["", "src/main/resources/META-INF/"]
    private static final String[] LICENSE_FILE_NAMES = ["LICENSE", "NOTICE", "COPYRIGHT"]
    private static final String[] LICENSE_FILE_EXTENSIONS = ["", "md", "txt"]

    private static final Map<String, String> URL_CACHE = Collections.synchronizedMap([:].withDefault { key ->
        HttpURLConnection connection = new URL(key).openConnection()
        connection.requestMethod = 'GET'
        if (connection.responseCode == 200) {
            return connection.inputStream.text
        }
        return ""
    })

    private Map<String, String> licenseToComponent = [:]

    @InputFile
    abstract RegularFileProperty getXmlReport()

    @OutputFile
    abstract RegularFileProperty getTextReport()

    String tryFetchLicense(String connection, String fromComponent) {
        if (!connection) {
            return
        }
        String baseUri = null
        def idx = connection.indexOf("http://bitbucket.org/")
        if (idx == -1) {
            idx = connection.indexOf("https://bitbucket.org/")
        }
        if (idx == -1) {
            idx = connection.indexOf("https://gitlab.ow2.org/")
        }
        if (idx > 0) {
            baseUri = "${connection.substring(idx).replace('http:', 'https:')}/raw/master"
        } else {
            idx = connection.indexOf("github.com")
            if (idx > 0) {
                String path = connection.substring(idx + 10).replaceAll(':', '/') - ".git"
                baseUri = "https://raw.githubusercontent.com/$path/master"
            }
        }

        if (baseUri) {
            String result = tryManyLicenses(baseUri, fromComponent)
            if (result) {
                return result
            }
        } else {
            println("Unknown connection -> $connection")
        }
        return ""
    }

    String deduplicate(String licenseText, String fromComponent) {
        String normalized = licenseText.trim()
        String cid = licenseToComponent[normalized]
        if (cid) {
            return "Same as $cid"
        }
        licenseToComponent[normalized] = fromComponent
        licenseText
    }

    String tryManyLicenses(String baseUri, String fromComponent) {
        StringBuilder sb = new StringBuilder()
        [LICENSE_FILE_PATHS, LICENSE_FILE_NAMES, LICENSE_FILE_EXTENSIONS].combinations().each { fp, f, ext ->
            def fn = ext ? "${f}.${ext}" : f
            def txt = URL_CACHE.get("${baseUri}/${fp}${fn}")
            if (txt) {
                sb.append("${fn}\n")
                sb.append("-" * fn.length()).append("\n")
                sb.append(deduplicate(txt, fromComponent)).append("\n\n")
            }
        }
        return sb.toString()
    }

    String fetchLicenseTextFromRepo(String componentId) {
        try {
            def (String g, String a, String v) = componentId.split(':')
            def result = project.dependencies.createArtifactResolutionQuery()
                    .forModule(g, a, v)
                    .withArtifacts(MavenModule, MavenPomArtifact)
                    .execute()
            def tentativeLicense = null
            result.resolvedComponents.each {
                it.getArtifacts(MavenPomArtifact).each {
                    if (tentativeLicense) {
                        return
                    }
                    def xmlFile = it.file
                    def xml = new XmlSlurper().parse(xmlFile)
                    def connection = xml.scm.connection ? xml.scm.connection[0].text() : ""
                    if (!connection) {
                        // Let's see if we can get it from the parent pom
                        if (xml.'parent'.groupId.text()) {
                            def parentPom = "${xml.'parent'.groupId.text()}:${xml.'parent'.artifactId.text()}:${xml.'parent'.version.text()}"
                            tentativeLicense = fetchLicenseTextFromRepo(parentPom)
                        }
                    } else {
                        tentativeLicense = tryFetchLicense(connection, "$g:$a:$v")
                    }
                    if (!tentativeLicense || tentativeLicense == NOT_FOUND) {
                        tentativeLicense = xml.licenses.license.url*.text().join(" ")
                    }
                }
            }
            result.components
                    .findAll { it instanceof UnresolvedComponentResult }
                    .each {
                        ((UnresolvedComponentResult) it).failure.printStackTrace()
                    }
            return tentativeLicense ?: NOT_FOUND
        } catch (e) {
            println "Unexpected error while processing $componentId"
            e.printStackTrace()
            return NOT_FOUND
        }
    }

    @TaskAction
    void execute() {
        def xmlFile = xmlReport.get().asFile
        def txtFile = textReport.get().asFile
        txtFile.withWriter { writer ->
            def baseDir = xmlFile.parentFile.toPath()
            def xml = new XmlSlurper()
                    .parse(xmlFile)
            def registerLicense = { id, node ->
                def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
                def uri
                if (lic) {
                    uri = node.@uri.text()
                    if (uri) {
                        writer.println("$lic: $uri")
                        writer.println()
                    } else {
                        def licenseText = fetchLicenseTextFromRepo(id)
                        writer.println("$lic: $licenseText")
                    }
                }
            }
            // At the top of the file we put a list of all dependencies
            def components = [] as LinkedHashSet
            xml.components.component.each {
                def id = it.@id.text()
                if (id.startsWith('io.micronaut')) {
                    // skip this component
                    return
                }
                components << id
            }
            components = components.sort()
            components.each {
                writer.println(it)
            }
            writer.println()
            writer.println(LICENSE_LIST_HEADER)
            writer.println("-------------")

            // Then licenses for each component
            // also sorted
            components.each { compId ->
                xml.components.component.each {
                    String id = it.@id.text()
                    if (id != compId) {
                        return
                    }
                    def path = it.@licenseFiles.text()
                    writer.println(id)
                    writer.println('=' * id.length())
                    boolean hasLicenses = false
                    if (path) {
                        def licenses = baseDir.resolve(path).toFile()
                        if (licenses.exists()) {
                            licenses.listFiles().each {
                                hasLicenses = true
                                writer.println(it.name)
                                writer.println("-" * (it.name.length()))
                                writer.println(deduplicate(it.text, id))
                            }
                        }
                        writer.println()
                    }
                    if (!hasLicenses) {
                        it.'license-expression'.each { expr ->
                            expr.license.each {
                                registerLicense(id, it)
                            }
                            expr.and.license.each {
                                registerLicense(id, it)
                            }
                            expr.or.license.each {
                                registerLicense(id, it)
                            }
                            expr.expression.each {
                                registerLicense(id, it)
                            }
                        }
                    }
                }

            }
        }
        println "Wrote $txtFile"
    }
}
