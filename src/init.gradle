import com.github.vlsi.gradle.license.api.*
import groovy.json.JsonOutput
import groovy.json.StreamingJsonBuilder
import groovy.xml.DOMBuilder
import groovy.xml.XmlSlurper
import org.eclipse.jgit.api.Git

import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

initscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        mavenCentral()
    }
    dependencies {
        classpath "com.github.vlsi.gradle:license-gather-plugin:1.74"
        classpath "org.codehaus.groovy:groovy-xml:3.0.8"
        classpath "org.codehaus.groovy:groovy-json:3.0.8"
        classpath "org.eclipse.jgit:org.eclipse.jgit:6.4.0.202211300538-r"
    }
}

rootProject {

    def includeMicronautModulesProperty = providers.gradleProperty("includeMicronautModules").map(String::toBoolean).getOrElse(false)
    def excludedModuleIdsProperty = providers.gradleProperty("excludedModuleIds").getOrElse("")
    def addCopyrightsFromSourceProperty = providers.gradleProperty("addCopyrightsFromSource").map(String::toBoolean).getOrElse(false)
    def nettyNoticeProperty = providers.gradleProperty("nettyNotice").getOrElse("")
    def aggregator = rootProject.tasks.register("licenseReport", ReportAggregator) {
        jsonAggregatedReport.set(layout.buildDirectory.file("reports/licenseReport/report.json"))
        mergedXMLReport.set(layout.buildDirectory.file("reports/licenseReport/all-licenses.xml"))
    }

    def dependencyTree = tasks.register("dependencyTree", DependencyTree) {
        Configuration config = project.getConfigurations().findByName("allCodeCoverageReportClassDirectories")
        if(config == null) {
            config = project.getConfigurations().findByName("javadocAggregatorClasspath")
        }
        rootComponent = config.getIncoming().getResolutionResult().getRoot()
        def parentDir = rootProject.projectDir.parentFile.parentFile.absolutePath
        def excludedDeps = new File(parentDir + "/src/resources/excluded_deps.txt")
        if(excludedDeps.exists()) {
            excludedDepsFile = excludedDeps
        }
        dependencyTreeReport = rootProject.layout.buildDirectory.file("licenses/tree_all.txt")
        excludedDepsLogFile = rootProject.layout.buildDirectory.file("licenses/excluded_dependencies.txt")
        if(excludedDepsLogFile.get().asFile.exists())
            excludedDepsLogFile.get().asFile.delete()
    }

    def findCopyrights = tasks.register("findCopyrights", FindCopyrights){
        dependsOn(dependencyTree)
        dependencyTreeFile = rootProject.layout.buildDirectory.file("licenses/tree_all.txt")
        includeCopyrights.set(addCopyrightsFromSourceProperty)
        additionalCheckoutsDir = rootProject.objects.directoryProperty().convention(rootProject.layout.buildDirectory.dir("additional-checkouts"))
        includeMicronautModules.set(includeMicronautModulesProperty)
    }

    def aggregatedText = tasks.register("licenseReportAggregatedText", LicenseReportText) {
        dependsOn(findCopyrights)
        dependencyTreeFile = rootProject.layout.buildDirectory.file("licenses/tree_all.txt")
        xmlReport = aggregator.flatMap(r -> r.mergedXMLReport)
        textReport = rootProject.layout.buildDirectory.file("licenses/all.txt")
        includeMicronautModules.set(includeMicronautModulesProperty)
        excludedModuleIds.set(excludedModuleIdsProperty)
        includeCopyrights.set(addCopyrightsFromSourceProperty)
        additionalCheckoutsDir = rootProject.objects.directoryProperty().convention(rootProject.layout.buildDirectory.dir("additional-checkouts"))
        nettyNoticePath.set(nettyNoticeProperty)
        def parentDir = rootProject.projectDir.parentFile.parentFile.absolutePath
        def mnCopyrights = new File(parentDir + "/src/resources/mn_copyrights.txt")
        if(mnCopyrights.exists()) {
            micronautCopyrightsFile = mnCopyrights
        }
    }

    allprojects {
        pluginManager.withPlugin('java') {
            pluginManager.withPlugin('maven-publish') {
                publishing {
                    publications.withType(MavenPublication).configureEach { pub ->
                        def singleReport = tasks.register("generateLicense", com.github.vlsi.gradle.license.GatherLicenseTask) {
                            configurations.set([project.configurations.runtimeClasspath])
                            SpdxLicense.values().each {
                                ignoreMissingLicenseFor(it)
                            }
                        }
                        aggregator.configure {
//                dependsOn(singleReport)
                            mustRunAfter(singleReport)
                            reports.from(new File(singleReport.get().licenseDir.asFile.get(), "license.xml"))
                        }
                        def dependencyTreeSubproject = tasks.register("dependencyTree", DependencyTree){
                            mustRunAfter(singleReport)
                            rootComponent = project.getConfigurations()
                                    .findByName("runtimeClasspath")
                                    .getIncoming()
                                    .getResolutionResult()
                                    .getRoot()
                            def parentDir = rootProject.projectDir.parentFile.parentFile.absolutePath
                            def excludedDeps = new File(parentDir + "/src/resources/excluded_deps.txt")
                            if(excludedDeps.exists()) {
                                excludedDepsFile = excludedDeps
                            }
                            dependencyTreeReport = rootProject.layout.buildDirectory.file("licenses/tree_${pub.groupId}:${pub.artifactId}.txt")
                            excludedDepsLogFile = rootProject.layout.buildDirectory.file("licenses/excluded_dependencies.txt")
                        }
                        def findCopyrightsSubproject = tasks.register("findCopyrights", FindCopyrights){
                            dependsOn(dependencyTreeSubproject)
                            dependencyTreeFile = rootProject.layout.buildDirectory.file("licenses/tree_${pub.groupId}:${pub.artifactId}.txt")
                            includeCopyrights.set(addCopyrightsFromSourceProperty)
                            additionalCheckoutsDir = rootProject.objects.directoryProperty().convention(rootProject.layout.buildDirectory.dir("additional-checkouts"))
                            includeMicronautModules.set(includeMicronautModulesProperty)
                        }
                        def licenseReportText = tasks.register("licenseReportText", LicenseReportText) {
                            dependsOn(findCopyrightsSubproject)
                            dependencyTreeFile = rootProject.layout.buildDirectory.file("licenses/tree_${pub.groupId}:${pub.artifactId}.txt")
                            xmlReport = new File(singleReport.get().licenseDir.asFile.get(), "license.xml")
                            textReport = rootProject.layout.buildDirectory.file("licenses/${pub.groupId}:${pub.artifactId}.txt")
                            includeMicronautModules.set(includeMicronautModulesProperty)
                            excludedModuleIds.set(excludedModuleIdsProperty)
                            includeCopyrights.set(addCopyrightsFromSourceProperty)
                            additionalCheckoutsDir = rootProject.objects.directoryProperty().convention(rootProject.layout.buildDirectory.dir("additional-checkouts"))
                            def modules = configurations.runtimeClasspath
                                    .incoming
                                    .resolutionResult
                                    .allDependencies
                                    .findAll { it instanceof ResolvedDependencyResult }
                                    .collect { it.selected }
                                    .findAll { it.id instanceof ProjectComponentIdentifier }
                                    .collect { it.moduleVersion.toString() }
                            aggregatedText.configure {
                                micronautModules.addAll(modules)
                            }
                            micronautModules.set(modules)
                            nettyNoticePath.set(nettyNoticeProperty)
                            def parentDir = rootProject.projectDir.parentFile.parentFile.absolutePath
                            def mnCopyrights = new File(parentDir + "/src/resources/mn_copyrights.txt")
                            if(mnCopyrights.exists()) {
                                micronautCopyrightsFile = mnCopyrights
                            }
                        }
                    }
                }
            }
        }
    }
}


class UtilClass {
    static String moduleNameOf(String name) {
        if (name.startsWith("micronaut-")) {
            return name
        }
        return "micronaut-$name"
    }

    static String findConnection(Project project, String dep){
        def (String g, String a, String v) = dep.split(":")
        ArtifactResolutionResult res = project.dependencies.createArtifactResolutionQuery()
                .forModule(g, a, v)
                .withArtifacts(MavenModule, MavenPomArtifact)
                .execute()

        def connection = null
        res.resolvedComponents.each {
            it.getArtifacts(MavenPomArtifact).each {
                if (connection) {
                    return
                }

                def xmlFile = it.file
                def xml = new XmlSlurper().parse(xmlFile)
                connection = xml.scm.connection ? xml.scm.connection[0].text() : ""

                if (!connection) {
                    if (xml.'parent'.groupId.text()) {
                        def parentPom = "${xml.'parent'.groupId.text()}:${xml.'parent'.artifactId.text()}:${xml.'parent'.version.text()}"
                        connection = findConnection(project, parentPom)
                    }
                }
            }
        }

        return connection
    }

    static String findBaseUri(String connection) {
        if (!connection) {
            return null
        }
        String baseUri = null
        def idx = connection.indexOf("http://bitbucket.org/")
        if (idx == -1) {
            idx = connection.indexOf("https://bitbucket.org/")
        }
        if (idx == -1) {
            idx = connection.indexOf("https://gitlab.ow2.org/")
        }
        if (idx == -1) {
            idx = connection.indexOf("http://gitbox.apache.org/")
            if (idx != -1) {
                //Changing the source site from gitbox to github by getting the name of the module from the connection,
                // as it is easier to work with than gitbox
                String path = "apache/" + connection.tokenize('/').last() - ".git"
                baseUri = "https://raw.githubusercontent.com/$path/master"
            }
        }
        if (idx > 0 && baseUri == null) {
            baseUri = "${connection.substring(idx).replace('http:', 'https:')}/raw/master"
        } else {
            idx = connection.indexOf("github.com")
            if (idx > 0) {
                String path = connection.substring(idx + 10).replaceAll(':', '/')
                //Added because of the micrometer dependency with the connection /googleapis/java-common-protos.git/proto-google-common-protos
                def gitIndex = path.indexOf(".git")
                if (gitIndex > 0) {
                    path = path.substring(0, gitIndex)
                }
                path -= ".git"
                baseUri = "https://raw.githubusercontent.com/$path/master"
            }
        }
        return baseUri
    }

    static String makeDirName(String path){
        def split = path.tokenize("/")
        def dirName = split.last() - ".git"
        if(dirName == ""){
            if(split.size() < 2){
                return null;
            }
            dirName = split[split.size() - 2]
        }
        return dirName
    }
}

abstract class ReportAggregator extends DefaultTask {
    @InputFiles
    abstract ConfigurableFileCollection getReports()

    @OutputFile
    abstract RegularFileProperty getJsonAggregatedReport()

    @OutputFile
    abstract RegularFileProperty getMergedXMLReport()

    @TaskAction
    void execute() {
        writeJsonReport()
        mergeXMLReports()
    }

    private void mergeXMLReports() {
        def factory = DocumentBuilderFactory.newInstance()
        def builder = factory.newDocumentBuilder()
        def doc = builder.newDocument()
        def root = doc.createElement("license-list")
        doc.appendChild(root)
        root.setAttribute("version", "1")
        def componentsNode = root.appendChild(doc.createElement("components"))
        reports.files.each {
            if (it.exists()) {
                def dom = DOMBuilder.newInstance().parseText(it.text)
                dom.getElementsByTagName("component").each {
                    def imported = doc.importNode(it, true)
                    componentsNode.appendChild(imported)
                }
            }
        }

        def transformerFactory = TransformerFactory.newInstance()
        def trn = transformerFactory.newTransformer()

        trn.setOutputProperty(OutputKeys.ENCODING, "UTF-8")
        trn.setOutputProperty(OutputKeys.INDENT, "yes")
        trn.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")

        def file = new StreamResult(mergedXMLReport.get().asFile)

        trn.transform(new DOMSource(doc), file)

    }

    private void writeJsonReport() {
        def perComponent = [:].withDefault {
            [] as Set
        }
        def perLicense = [:].withDefault {
            [] as Set
        }
        def registerLicense = { id, node ->
            def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
            if (lic) {
                perComponent[id].add(lic)
                perLicense[lic].add(id)
            } else {
                println "License not found for $id!"
            }
        }
        reports.files.each {
            if (it.exists()) {
                def xml = new XmlSlurper()
                        .parse(it)
                xml.components.component.each {
                    def id = it.@id.text()
                    it.'license-expression'.each { expr ->
                        expr.license.each {
                            registerLicense(id, it)
                        }
                        expr.and.license.each {
                            registerLicense(id, it)
                        }
                        expr.or.license.each {
                            registerLicense(id, it)
                        }
                        expr.expression.each {
                            registerLicense(id, it)
                        }
                    }
                }
            }
        }
        def json = new StringWriter()
        new StreamingJsonBuilder(json).with { writer ->
            writer(
                    licenses: perLicense.collect { id, components ->
                        [license: [name: id, components: components]]
                    },
                    components: perComponent.collect { id, licenses ->
                        [component: [id: id, licenses: licenses]]
                    },
            )
        }
        jsonAggregatedReport.get().asFile.with {
            it.parentFile.mkdirs()
            it.text = JsonOutput.prettyPrint(json.toString())
            println "Wrote $it"
        }
    }
}

abstract class LicenseReportText extends DefaultTask {
    public static final String LICENSE_LIST_HEADER = "LICENSES LIST"
    private static final String NOT_FOUND = "License unavailable"
    private static final String[] LICENSE_FILE_PATHS = ["", "src/main/resources/META-INF/"]
    private static final String[] JACKSON_LICENSE_FILE_PATHS = ["datatypes/src/main/resources/META-INF/", "dataformat/src/main/resources/META-INF/"]
    private static final String[] LICENSE_FILE_NAMES = ["LICENSE", "License", "license", "NOTICE", "Notice", "notice", "COPYRIGHT", "Copyright", "copyright", "LGPL2.1"]
    private static final String[] LICENSE_FILE_EXTENSIONS = ["", "md", "txt"]
    private static final String COPYRIGHTS_FOR_DIR_FILENAME = "/copyrights_found.txt"

    private static final Map<String, String> URL_CACHE = Collections.synchronizedMap([:].withDefault { key ->
        HttpURLConnection connection = new URL(key).openConnection()
        connection.requestMethod = 'GET'
        if (connection.responseCode == 200) {
            return connection.inputStream.text
        }
        return ""
    })

    private Map<String, String> licenseToComponent = [:]
    private Set<String> usableDeps = []
    private Map<String, Set<String>> componentToCopyrights = [:]
    private Set<String> mnCopyrights = []

    @InputFile
    abstract RegularFileProperty getXmlReport()

    @OutputFile
    abstract RegularFileProperty getTextReport()

    @Input
    abstract Property<Boolean> getIncludeMicronautModules()

    @Input
    abstract Property<String> getExcludedModuleIds()

    @Optional
    @Input
    abstract SetProperty<String> getMicronautModules()

    @Internal
    abstract DirectoryProperty getRootDir()

    @InputFiles
    abstract RegularFileProperty getDependencyTreeFile()

    @InputFiles
    abstract DirectoryProperty getAdditionalCheckoutsDir()

    @Input
    abstract Property<Boolean> getIncludeCopyrights()

    @Input
    abstract Property<String> getNettyNoticePath()

    @Optional
    @InputFile
    abstract RegularFileProperty getMicronautCopyrightsFile()

    LicenseReportText() {
        rootDir.set(project.rootProject.layout.projectDirectory)
    }

    String tryFetchLicense(String connection, String fromComponent) {
        def baseUri = UtilClass.findBaseUri(connection)
        if (baseUri) {
            String result = tryManyLicenses(baseUri, fromComponent)
            if (result) {
                return result
            }
        } else {
            println("Unknown connection -> $connection")
        }
        return ""
    }

    String deduplicate(String licenseText, String fromComponent) {
        String normalized = licenseText.trim().replaceAll("[\\s\\{\\}\\[\\]\\(\\)]", "").replaceAll("https", "http")
        String cid = licenseToComponent[normalized]
        if (cid) {
            return "Same as " + removeVersion(cid)
        }
        licenseToComponent[normalized] = fromComponent
        licenseText
    }

    String removeVersion(String componentId) {
        def idForDisplay = componentId
        def lastIndexColon = componentId.lastIndexOf(":")
        if (lastIndexColon != -1) {
            idForDisplay = componentId.substring(0, lastIndexColon)
        }
        idForDisplay
    }

    StringBuilder appendLicense(String txt, String fn, String fromComponent, StringBuilder sb){
        sb.append("${fn}\n")
        sb.append("-" * fn.length()).append("\n")
        sb.append(deduplicate(txt, fromComponent)).append("\n\n")
        return sb
    }

    StringBuilder tryManyLicensesJackson(String baseUri, String fromComponent, Set<String> seen, StringBuilder sb){
        if(fromComponent.contains("jackson-modules-java8")) {
            baseUri = baseUri - "/master" + "/2.14"
        }
        [JACKSON_LICENSE_FILE_PATHS, LICENSE_FILE_NAMES, LICENSE_FILE_EXTENSIONS].combinations().each { fp, f, ext ->
            String fileName = f.toLowerCase()
            if(seen.contains(fileName)) {
                return
            }
            def fn = ext ? "${f}.${ext}" : f
            def txt = URL_CACHE.get("${baseUri}/${fp}${fn}")
            if (txt) {
                sb = appendLicense(txt, fn, fromComponent, sb)
                seen.add(fileName)
            }
        }
        return sb
    }

    String findNettyNotice(){
        def nettyNoticePathStr = nettyNoticePath.get()
        if(nettyNoticePathStr == ""){
            return ""
        }
        def nettyNoticeFile = new File(nettyNoticePathStr)
        if(!nettyNoticeFile.exists()){
            return ""
        }
        return nettyNoticeFile.text
    }

    String tryManyLicenses(String baseUri, String fromComponent) {
        StringBuilder sb = new StringBuilder()
        Set<String> seen = []
        if(fromComponent.contains("netty")){
            def txt = findNettyNotice()
            if(txt){
                sb = appendLicense(txt, "NOTICE", fromComponent, sb)
                seen.add("notice")
            }
        }
        [LICENSE_FILE_PATHS, LICENSE_FILE_NAMES, LICENSE_FILE_EXTENSIONS].combinations().each { fp, f, ext ->
            String fileName = f.toLowerCase()
            if(seen.contains(fileName)) {
                return
            }
            def fn = ext ? "${f}.${ext}" : f
            def txt = URL_CACHE.get("${baseUri}/${fp}${fn}")
            if (txt) {
                sb = appendLicense(txt, fn, fromComponent, sb)
                seen.add(fileName)
            }
        }
        if(fromComponent.toLowerCase().contains("jackson"))
            sb = tryManyLicensesJackson(baseUri, fromComponent, seen, sb)
        return sb.toString()
    }

    String fetchLicenseTextFromRepo(String componentId) {
        try {
            def (String g, String a, String v) = componentId.split(':')
            def result = project.dependencies.createArtifactResolutionQuery()
                    .forModule(g, a, v)
                    .withArtifacts(MavenModule, MavenPomArtifact)
                    .execute()
            def tentativeLicense = null
            result.resolvedComponents.each {
                it.getArtifacts(MavenPomArtifact).each {
                    if (tentativeLicense) {
                        return
                    }
                    def xmlFile = it.file
                    def xml = new XmlSlurper().parse(xmlFile)
                    def connection = xml.scm.connection ? xml.scm.connection[0].text() : ""
                    if (!connection) {
                        // Let's see if we can get it from the parent pom
                        if (xml.'parent'.groupId.text()) {
                            def parentPom = "${xml.'parent'.groupId.text()}:${xml.'parent'.artifactId.text()}:${xml.'parent'.version.text()}"
                            tentativeLicense = fetchLicenseTextFromRepo(parentPom)
                        }
                    } else {
                        tentativeLicense = tryFetchLicense(connection, "$g:$a:$v")
                    }
                    if (!tentativeLicense || tentativeLicense == NOT_FOUND) {
                        tentativeLicense = xml.licenses.license.url*.text().join(" ")
                    }
                }
            }
            result.components
                    .findAll { it instanceof UnresolvedComponentResult }
                    .each {
                        ((UnresolvedComponentResult) it).failure.printStackTrace()
                    }
            return tentativeLicense ?: NOT_FOUND
        } catch (e) {
            println "Unexpected error while processing $componentId"
            e.printStackTrace()
            return NOT_FOUND
        }
    }

    File[] findLicensesInDir(File licenseFile){
        def licenseFiles = []
        if(!licenseFile.isDirectory())
            licenseFiles << licenseFile
        else {
            licenseFile.eachFileRecurse { File file ->
                if (!file.isDirectory() && file.name.toUpperCase().startsWithAny(LICENSE_FILE_NAMES)) {
                    licenseFiles << file
                }
            }
        }
        return licenseFiles
    }

    boolean findUsableDepsFromTree(){
        File depTreeFile = dependencyTreeFile.get().asFile
        if(!depTreeFile.exists()) {
            return false
        }

        def lines = depTreeFile.readLines()
        for(String line in lines){
            String trimmed = line.trim()
            if(trimmed == "") {
                return true
            }
            usableDeps.add(trimmed)
        }
        return true
    }

    boolean checkUsableDep(String depId){
        if (includeMicronautModules.get() && depId.startsWith('io.micronaut')) {
            return true
        }
        if(usableDeps.contains(depId.trim())) {
            return true
        }
        return false
    }

    void findCopyrightsForDep(String dep, String connection){
        if(connection == null || connection.trim().isEmpty()){
            return
        }

        Set<String> copyrights = []
        def dirName = UtilClass.makeDirName(connection)
        if(dirName == null){
            return
        }
        def copyrightsFile = new File("${additionalCheckoutsDir.get().asFile.absolutePath}/${dirName}${COPYRIGHTS_FOR_DIR_FILENAME}")

        if(!copyrightsFile.exists()){
            return
        }

        def lines = copyrightsFile.readLines()
        for(def line in lines){
            copyrights.add(line)
        }

        componentToCopyrights[dep] = copyrights
    }

    void findMicronautCopyrights() {
        if (!micronautCopyrightsFile.isPresent()) {
            return
        }

        def mnCopyrightsFile = micronautCopyrightsFile.get().asFile
        def lines = mnCopyrightsFile.readLines()
        for (def line in lines) {
            mnCopyrights.add(line)
        }
    }

    void findCopyrights(){
        if(!includeCopyrights.get().booleanValue()){
            return
        }

        for(def dep in usableDeps){
            def conn = UtilClass.findConnection(project, dep)
            def gitIndex = conn.lastIndexOf(".git")
            if(gitIndex > 0) {
                conn = conn.substring(0, gitIndex)
            }
            findCopyrightsForDep(dep, conn)
        }

        findMicronautCopyrights()
    }

    void printCopyrights(String id, Writer writer){
        if(!includeCopyrights.get().booleanValue()){
            return
        }

        Set<String> copyrights = componentToCopyrights[id]
        if(copyrights == null || copyrights.isEmpty()){
            if (id.startsWith("io.micronaut")){
                copyrights = mnCopyrights
            } else {
                return
            }
        }
        writer.println("Copyrights")
        writer.println("----------")
        for(def copyright in copyrights){
            writer.println(copyright)
        }
        writer.print("\n\n")
    }

    @TaskAction
    void execute() {
        def xmlFile = xmlReport.get().asFile
        def txtFile = textReport.get().asFile
        if(!findUsableDepsFromTree()) {
            return
        }
        findCopyrights()
        txtFile.withWriter { writer ->
            def baseDir = xmlFile.parentFile.toPath()
            def xml = new XmlSlurper()
                    .parse(xmlFile)
            def registerLicense = { id, node ->
                def lic = node.@id.text() ?: node.@name.text() ?: node.text() ?: null
                def uri
                if (lic) {
                    uri = node.@uri.text()
                    if (uri) {
                        writer.println("$lic: $uri")
                        writer.println()
                    } else {
                        def licenseText = fetchLicenseTextFromRepo(id)
                        writer.println("$lic: $licenseText")
                    }
                }
            }
            // At the top of the file we put a list of all dependencies
            def components = [] as LinkedHashSet
            if (includeMicronautModules.get() && getMicronautModules().isPresent()) {
                getMicronautModules().get().each {
                    components << it
                }
            }
            xml.components.component.each {
                def id = it.@id.text()
                if (!includeMicronautModules.get() && id.startsWith('io.micronaut'))
                    // skip this component
                    return
                if(checkUsableDep((String) id)) {
                    components << id
                }
            }
            components = components.sort()
            components.each {
                writer.println(it)
            }
            writer.println()
            writer.println(LICENSE_LIST_HEADER)
            writer.println("-------------")
            // Then licenses for each component
            // also sorted
            components.each { compId ->
                if (compId.startsWith('io.micronaut')) {
                    // special case because we know it'a AL2
                    def idForDisplay = removeVersion(compId)
                    writer.println(idForDisplay)
                    writer.println('=' * idForDisplay.length())
                    File licFile = rootDir.file("LICENSE").get().asFile
                    if (licFile.exists()) {
                        writer.println(licFile.name)
                        writer.println("-" * (licFile.name.length()))
                        writer.println(deduplicate(licFile.text, compId))
                    } else {
                        writer.println("LICENSE file not found")
                    }
                    writer.println()
                    printCopyrights(compId, writer)
                    return
                }
                Set<String> usedModuleIds = []
                xml.components.component.each {
                    String id = it.@id.text()
                    if (id != compId) {
                        return
                    }
                    def path = it.@licenseFiles.text()
                    def idForDisplay = removeVersion(id)
                    //skip duplicates
                    if(!usedModuleIds.add(idForDisplay)){return}
//                  skip excluded Modules from the licenses report
                    def excluded_Module_Ids=excludedModuleIds.get().split(";")
                    if(excluded_Module_Ids.any {it && idForDisplay.contains(it)}){
                        return
                    }
                    writer.println(idForDisplay)
                    writer.println('=' * idForDisplay.length())
                    boolean hasLicenses = false
                    if (path) {
                        def licenses = baseDir.resolve(path).toFile()
                        if (licenses.exists()) {
                            licenses.listFiles().each {
                                //If the directory in which the licenses should be has subdirectories instead,
                                //check whether the licenses are present in any of those subfolders
                                def licFiles = findLicensesInDir(it).toList()
                                if(licFiles.isEmpty())
                                    return
                                hasLicenses = true
                                licFiles.each {File file ->
                                    writer.println(file.name)
                                    writer.println("-" * (file.name.length()))
                                    writer.println(deduplicate(file.text, id))
                                }
                            }
                        }
                        writer.println()
                    }
                    if (!hasLicenses) {
                        it.'license-expression'.each { expr ->
                            expr.license.each {
                                registerLicense(id, it)
                            }
                            expr.and.license.each {
                                registerLicense(id, it)
                            }
                            expr.or.license.each {
                                registerLicense(id, it)
                            }
                            expr.expression.each {
                                registerLicense(id, it)
                            }
                        }
                    }

                    printCopyrights(id, writer)
                }

            }
        }
        println "Wrote $txtFile"
    }
}


abstract class DependencyTree extends DefaultTask{

    private Set<String> excludedDeps = []
    private Set<String> excludedDepsForLog = []

    @Input
    abstract Property<ResolvedComponentResult> getRootComponent()

    @Optional
    @InputFile
    abstract RegularFileProperty getExcludedDepsFile()

    @OutputFile
    abstract RegularFileProperty getDependencyTreeReport()

    @OutputFile
    abstract RegularFileProperty getExcludedDepsLogFile()

    void printDependencyTree(){
        try {
            ResolvedComponentResult root = getRootComponent().get()
            Set<ComponentIdentifier> seen = []

            if(root == null){
                println("Couldn't find the root for the given configuration")
                return
            }

            computeExcludedDeps()
            seen.add(root.id)
            StringBuilder sb = new StringBuilder()

            if(checkExcludedDeps(root.id)) {
                logExcludedDeps(root.id.displayName, true)
                return
            }

            sb = printDependencyTreePreorder(root, seen, 0, "", sb)
            def seenSorted = seen.sort{it.displayName}

            def depTreeFile = dependencyTreeReport.get().asFile
            if(!depTreeFile.exists()) {
                depTreeFile.createNewFile()
            }

            depTreeFile.withWriter {writer ->
                seenSorted.each {compId ->
                    if(!compId.displayName.trim().toLowerCase().startsWith("project")) {
                        writer.println(compId.displayName)
                    }
                }

                writer.println()
                writer.println(sb.toString())
            }
            logExcludedDeps(root.id.displayName, false)
        }catch(Exception e){
            return
        }
    }

    void computeExcludedDeps(){
        if(!excludedDepsFile.isPresent()) {
            return
        }

        File exclusionsFile = excludedDepsFile.get().asFile
        def lines = exclusionsFile.readLines()

        for(String line in lines){
            excludedDeps.add(line.trim())
        }
    }

    StringBuilder printDependencyTreePreorder(ResolvedComponentResult root,
                                              Set<ComponentIdentifier> seen,
                                              int depth,
                                              String beforeComponent,
                                              StringBuilder sb){

        Set<DependencyResult> dependencies = root.getDependencies()
        Set<ComponentIdentifier> seenBranch = []
        sb = printDependency(root, beforeComponent, sb, false, depth, dependencies.isEmpty())
        if(depth > 0 && !dependencies.isEmpty()) {
            beforeComponent += "|   "
        }

        for(DependencyResult d: dependencies) {
            if (!(d instanceof ResolvedDependencyResult)) {
                sb.append(beforeComponent + "---- ")
                sb.append("Unresolved dependency: " + d.toString() + "\n")
                continue
            }

            ResolvedComponentResult dependencyComponent = ((ResolvedDependencyResult) d).getSelected()
            ComponentIdentifier dependencyId = dependencyComponent.getId()

            if(checkExcludedDeps(dependencyId)) {
                continue
            }

            if(seen.add(dependencyId)) {
                sb = printDependencyTreePreorder(dependencyComponent, seen, depth + 1, beforeComponent + "    ", sb)
            }
            else if(!seenBranch.contains(dependencyId)) {
                sb = printDependency(dependencyComponent, beforeComponent + "    ", sb, true, depth + 1, dependencyComponent.getDependencies().isEmpty())
            }

            seenBranch.add(dependencyId)
        }
        return sb
    }

    boolean checkExcludedDeps(ComponentIdentifier dependencyId){
        for(String exclusion in excludedDeps){
            if(dependencyId.displayName.contains(exclusion)) {
                excludedDepsForLog.add(dependencyId.displayName)
                return true
            }
        }
        return false
    }

    StringBuilder printDependency(ResolvedComponentResult root,
                                  String beforeComponent,
                                  StringBuilder sb,
                                  boolean alreadySeen,
                                  int depth,
                                  boolean emptyDependencies){

        sb.append(beforeComponent)
        if(depth > 0) {
            if (emptyDependencies) {
                sb.append("/--- ")
            }
            else {
                sb.append("+--- ")
            }
        }
        sb.append(root.getId().getDisplayName())
        if(alreadySeen == true) {
            sb.append(" (*)")
        }
        sb.append("\n")
        return sb
    }

    void logExcludedDeps(String projectId, boolean wholeProjectExclusion){
        def logFile = excludedDepsLogFile.get().asFile
        String excl = makeExclusionSb(projectId)

        logFile.withWriterAppend {writer ->
            if(wholeProjectExclusion == true){
                writer.println("[${projectId}]: Whole project is excluded\n")
                return
            }

            if(excl != null)
                writer.println(excl)
        }
    }

    String makeExclusionSb(String projectId){
        if(excludedDepsForLog.isEmpty())
            return null

        StringBuilder sb = new StringBuilder()
        sb.append("[${projectId}] - ")
        for(String excl in excludedDepsForLog){
            sb.append("${excl}, ")
        }

        def sbString = sb.toString()
        def retStr = sbString.substring(0, sbString.length() - 2) + "\n"
        return retStr
    }

    @TaskAction
    void execute(){
        printDependencyTree()
    }
}

abstract class FindCopyrights extends DefaultTask{

    private Set<String> usableDeps = []
    private Map<String, String> componentToConnection = [:]

    private static final String COPYRIGHTS_FOR_DIR_FILENAME = "/copyrights_found.txt"

    @InputFiles
    abstract RegularFileProperty getDependencyTreeFile()

    @InputFiles
    abstract DirectoryProperty getAdditionalCheckoutsDir()

    @Input
    abstract Property<Boolean> getIncludeCopyrights()

    @Input
    abstract Property<Boolean> getIncludeMicronautModules()

    boolean findUsableDepsFromTree(){
        File depTreeFile = dependencyTreeFile.get().asFile
        if(!depTreeFile.exists()) {
            return false
        }

        def lines = depTreeFile.readLines()
        for(String line in lines){
            String trimmed = line.trim()
            if(trimmed == "") {
                return true
            }
            usableDeps.add(trimmed)
        }
        return true
    }

    void mapCompToConnection(String compId, String connection){
        def normalizedCompId = compId.trim()
        if(!includeMicronautModules.get() && normalizedCompId.startsWith("io.micronaut")){
            return
        }

        def existingConn = componentToConnection[normalizedCompId]
        if(existingConn) {
            return
        }

        String properConnection = UtilClass.findBaseUri(connection)
        if(properConnection != null && !properConnection.trim().isEmpty()) {
            properConnection = properConnection - "/master" - "/raw"
            if(properConnection.endsWith("/")){
                properConnection = properConnection.substring(0, properConnection.length() - 1)
            }
            if(!properConnection.endsWith(".git")){
                properConnection += ".git"
            }
            properConnection = properConnection.replaceAll("\\.githubusercontent", "/github")
            componentToConnection[normalizedCompId] = properConnection
        }
    }

    void checkoutReposAndGetCopyrights(){
        for(def entry in componentToConnection){
            def dirName = UtilClass.makeDirName(entry.value)
            if(dirName == null){
                continue
            }

            def checkoutDir = additionalCheckoutsDir.file("${dirName}").get().asFile
            if(!checkoutDir.exists()){
                tryCheckout(entry.value, checkoutDir)
            }
        }
    }

    void tryCheckout(String connection, File checkoutDir){
        def gitRepo = null
        try {
            println("Checking out repository ${connection} in ${checkoutDir.absolutePath}")
            gitRepo = Git.cloneRepository()
                    .setURI(connection)
                    .setDirectory(checkoutDir)
                    .call()
            findCopyrightsInDir(checkoutDir)
        }catch(Exception e){
            println("Checkout failed")
        }finally{
            if(gitRepo != null){
                gitRepo.close()
            }
        }
    }

    void findCopyrightsInDir(File checkoutDir){
        Set<String> actualCopyrights = []
        Set<String> copyrightsToCompare = []
        File copyrightsFile = new File(checkoutDir.absolutePath + COPYRIGHTS_FOR_DIR_FILENAME)

        if(copyrightsFile.exists() || !checkoutDir.exists()) {
            return
        }

        copyrightsFile.createNewFile()
        checkoutDir.eachFileRecurse {file ->
            if(!file.name.endsWith(".java") && !file.name.endsWith(".h")){
                return
            }

            file.withReader { r ->
                def copyrightFoundFlag = false
                def line
                while ((line = r.readLine()) != null) {
                    def normalizedLine = line.replaceAll("[\\/\\*]", '').trim()
                    def lineToCompare = normalizedLine.replaceAll("[^a-zA-Z]", "").toLowerCase()

                    if (normalizedLine.toLowerCase().startsWith("copyright")) {
                        if (copyrightsToCompare.add(lineToCompare)) {
                            actualCopyrights.add(normalizedLine)
                        }
                        copyrightFoundFlag = true
                    } else if (copyrightFoundFlag) {
                        break
                    }

                    if (normalizedLine.toLowerCase().contains("package")) {
                        break
                    }
                }
            }

            copyrightsFile.withWriter {writer ->
                for(def copyright in actualCopyrights){
                    writer.println(copyright)
                }
            }
        }
    }

    @TaskAction
    void execute(){
        if(!includeCopyrights.get().booleanValue() || !findUsableDepsFromTree()) {
            return
        }

        for(def dep in usableDeps){
            def conn = UtilClass.findConnection(project, dep)
            mapCompToConnection(dep, conn)
        }

        checkoutReposAndGetCopyrights()
    }
}
